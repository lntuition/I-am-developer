## 내가 알았던 객체지향 이란
- 객체 간의 상호작용을 통해 작동하는 프로그램을 만드는 Paradigm
- 잘 만들어진 객체지향이란 → 객체간의 책임이 뚜렷하고, 경계가 명확하며, 일관성 있는 의존성을 가져야한다.

#### 성질
- Abstraction : 객체에서 행위(Method)와 속성(Property)를 추출하는 것
- Encapsulation : 객체에 변수와 함수를 묶는 것
- Inheritance : 부모 객체의 속성을 자식에게 물려 주는 것
- Polymorphism : 같은 이름이지만 다른 행동을 하는 것 → Overriding / Overloading

#### Q/A
Q. Overriding / Overloading 시에 Return 값은 어떻게 되어야하는가?  
A. Overriding 시에는 무조건 같아야 하고, Overloading 시에는 다를 수도 있다. Calculator의 Add(int, int) -> int 를 생각해보면 쉽게 이해할 수 있을 듯

#### 잘 설계하기 위해서는 → SOILD
- Single Responsibility : 객체는 단 한가지일만 수행하여야 한다
- Open-Closed : 인터페이스 등을 사용하여 기존의 코드를 변경하지 않으면서 추가할 수 있도록 하여야 한다.
- Liskov Substituition : 자식은 부모가 하는 행동을 수행할 수 있어야 한다.
- Interface Segregation : 인터페이스는 작고 구체적이야 한다.
- Dependency Inversion : 객체간의 의존관계는 원칙을 가지고 있어야 한다.

## Objects : 코드로 이해하는 객체지향 설계

### 1장 : 객체, 설계
1. 티켓 판매 애플리케이션
#### Requirement
- 관람객은 초대장/현금/티켓을 가지고 있는 가방을 가지고 있다
- 매표소에서 초대장을 티켓으로 교환하거나 구매한다. → 티켓과 티켓의 판매금액을 보관한다.
- 판매원은 초대장을 티켓으로 교환하거나 돈을 받고 티켓을 판매한다.

#### Code
- 작성 시간이 너무 많이 걸림(약 4시간) - 코드를 많이 작성해 보지 않아서 그렇지 않을까?

2. 무엇이 문제인가 / 설계 개선하기 / 객체지향 설계
- 잘 작동하고, 변경이 용이해야 하며, 이해하기 쉬운 코드가 만들어져야 한다.
- 변경에 취약한 이유 → 객체 사이에 불필요한 의존성(Dependency)이 있는 것, 결합도(Coupling)를 낮추어야 한다
- 객체의 자율성을 높여야 한다 → 객체가 자신을 스스로 책임 질 수 있도록 캡슐화를 적용한다.
- 현실에서 수동적일지라도 객체 지향에서는 모든 객체가 능동적이여야 한다. → 의인화(anthropomorphism)
- 설계는 항상 **Trade-Off** 라는 것을 명심하자.

### 2장 : 객체지향 프로그래밍
1. 영화 예매 시스템
#### Requirement
- 영화는 영화에 대한 기본 정보(제목, 상영시간, 가격정보, etc)를 가지고 있다. 
- 상영은 실제로 관객들이 영화를 관람하는 사건을 표현한다.
- 할인 조건은 가격의 할인 여부를 결정하며, 순서 조건과 기간 조건의 두 종류로 나눌 수 있다 → 여러개의 조건을 적용할 수 있음(OR)
- 할인 정책은 가격의 할인 요금을 결정하며, 금액 할인 정책과 비율 할인 정책이 있다 → 영화별로 하나의 할인 정책만 가능
- 예매완료시 제목, 상영정보, 인원, 정가, 결제 금액을 포함한 예매 정보를 생성

#### Code
- 유연성이 떨어지는 것처럼 느껴짐 

2. 객체 지향 프로그래밍을 향해 / 할인 요금 구하기 / 상속과 다형성 / 추상화와 유연성
- 도메인을 구성하는 개념과 관계를 표현 → 할인 정책이 있는 경우에만 조건이 있다는 것을 파악할 수 있다
- 객체간의 상호작용을 위해 메시지를 전송하고 수신하는 부분이 필요
- **Template Pattern** : 부모클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 것 
- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다 → 코드가 유연성이 높아지지만 이해하기 어려워진다.
- 차이에 의한 프로그래밍 : 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
- **Polymorphism** : 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력(실제 어떤 메소드가 실행되는가)
- 상속 → 캡슐화를 위반하고 설계를 유연하지 못하게 할 수 있다, 합성 → 메시지를 통해 느슨하게 연결되므로 조금 더 선호됨

### 3장 : 역할, 책임, 협력
1. 협력
- 협력 : 객체가 기능을 구현하기 위해 수행하는 상호작용
- 메시지 전송을 통해 다른 객체와 커뮤니케이션 → 객체의 행동을 결정
- 객체를 설계하는 데 필요한 문맥(context)를 제공해 줌

2. 책임
- 책임 : 객체에 의해 정의되는 응집도 있는 행위의 집합
- '하는 것'과 '아는 것' → 객체에 책임을 할당하기 위한 가장 기본적인 원칙
- **Information Expert Pattern** : 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 책임을 할당하는 것 → Responsibility Driven Design 
- 메시지가 객체를 결정 : 객체가 최소한의 인터페이스(mininal interface), 충분히 추상적인 인터페이스(abstract interface)를 가지게 됨
- 행동이 상태를 결정 : 협력이 행동을 결정하고 행동이 상태를 결정한다 → Data Drivien Design

3. 역할
- 역할 : 객체가 특정한 협력 안에서 수행하는 책임의 집합
- 유연하고 재사용 가능한 협력 → Abstraction
